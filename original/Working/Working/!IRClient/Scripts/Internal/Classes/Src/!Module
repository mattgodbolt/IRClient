REM >Internal.Classes.!Module
REM (c) 1997 Matthew Godbolt
REM This file registers and administers the internal classes
REM Do not edit this file, if you wish to add extra fields to the
REM classes, simply add them in your initialisation routines. Note
REM that once a class has active instantiations, you cannot modify
REM the fields.
REM ---
REM $Id: !Module 1.5 98/02/01 16:04:06 gerph Exp $
REM $Log:	!Module $
REM Revision 1.5  98/02/01  16:04:06  gerph
REM Moved misc routines into MiscUtils, fixed
REM bugs in List class.
REM 
REM Revision 1.4  98/01/23  01:45:48  gerph
REM Fixed parts of file class, modified List class and added
REM List_Last
REM
REM Revision 1.3  97/12/29  14:44:10  gerph
REM Minor bug fixes, added ListItem_Destroy,
REM added FNstricmp (needs to move to the
REM machine code soon)
REM
REM Revision 1.2  97/04/16  01:27:57  gerph
REM Added List_Destroy.
REM
REM ---
PRINT "$Id: !Module 1.5 98/02/01 16:04:06 gerph Exp $"
END
:
:
REM Register up the internal classes needed for the rest of
REM initialisation
DEF PROCClasses_Initialise
 LOCAL filelist
 Class_Block      = FNRegisterClass("Block")
 PROCAddField(Class_Block,"data")

 Class_String      = FNRegisterClass("String")
 PROCAddField(Class_String,"data$")

 Class_File       = FNRegisterClass("File")
 PROCAddField(Class_File,"filehandle")
 PROCAddField(Class_File,"block")
 PROCAddField(Class_File,"size")
 PROCAddField(Class_File,"ptr")
 PROCAddField(Class_File,"writeflag")

 Class_FileList   = FNRegisterClass("FileList")
 PROCAddField(Class_FileList,"filename$")
 PROCAddField(Class_FileList,"filetype")
 PROCAddField(Class_FileList,"objtype")
 PROCAddField(Class_FileList,"length")
 PROCAddField(Class_FileList,"attribs")
 REM Sub-directory will be 0 /unless/ objtype is 2 and recursion
 REM has been specified (or you've created it yourself)
 PROCAddField(Class_FileList,"subdir")
 REM Parent is a pointer to the name of the parent of this tree
 REM and will be destroyed when all the items in this list die
 PROCAddField(Class_FileList,"parent")

 Class_List       = FNRegisterClass("List")
 PROCAddField(Class_List,"items")

 Class_ListItem   = FNRegisterClass("ListItem")
 PROCAddField(Class_ListItem,"next")
 PROCAddField(Class_ListItem,"data")

 list = FNnewListOfFilenames("<IRClient$Dir>.Scripts.Internal.Classes","*")
 PROClist.Iterate("Class_LoadFile")

 PROCStartupStatus("Initialising Classes")
 PROCOverload_Classes_Initialise
ENDPROC
:
:
DEF PROCOverload_Classes_Initialise
ENDPROC

DEF PROCClass_LoadFile(string)
 IF string.data$<>"!Module" THEN
  PROCStartupStatus("Loading "+string.data$)
  LOAD "<IRClient$Dir>.Scripts.Internal.Classes."+string.data$
 ENDIF
ENDPROC

REM Called by IRClient to construct
DEF PROCConstruct(class,instance)
PROCinstance.Construct
ENDPROC
:
REM Called by IRClient to destruct
DEF PROCDestruct(class,instance)
PROCinstance.Destruct
ENDPROC
:
REM Catch any destroy's mislaid
DEF PROCObject_Destroy
ENDPROC

DEF PROCObject_Destruct
ENDPROC

DEF PROCObject_Construct
ENDPROC
:
DEFFNObject_String
="<"+FNGetClassName(@)+" instance>"
:
REM Creates a memory-safe block of data
DEF FNnewBlock(size)
 LOCAL block
 block = NEW Class_Block
 block.data = FNClaim(size)
=block
:
DEF PROCBlock_Destruct
PROCRelease(@.data)
REM Pass on to any other destructors
PROC@
ENDPROC

REM Creates/opens a file
REM mode$ = ">"  for output,
REM         ">>" to append to a file
REM         "<"  to read from a file
DEF FNnewFile(filename$,mode$)
 LOCAL file
 file = FNnewFile_Internal(filename$,mode$)
 IF file = 0 THEN
  REM Could be a stale un-GC'd file struct leaving a file open
  PROCGarbageCollect
  file = FNnewFile_Internal(filename$,mode$)
 ENDIF
=file
:
DEF FNnewFile_Internal(filename$,mode$)
 LOCAL file
 file = NEW Class_File
 file.block = FNnewBlock(1024)
 CASE mode$ OF
  WHEN ">"
   file.filehandle = OPENOUT(filename$)
   file.writeflag  = 1
  WHEN ">>"
   file.filehandle = OPENUP(filename$)
   IF file.filehandle = 0 THEN
    file.filehandle = OPENOUT(filename$)
   ENDIF
   IF file.filehandle <> 0 THEN
    PTR#(file.filehandle) = EXT#(file.filehandle)
    file.ptr        = PTR#(file.filehandle)
   ENDIF
   file.writeflag  = 1
  WHEN "<"
   file.filehandle = OPENIN(filename$)
 ENDCASE
 IF file.filehandle = 0 THEN
  file = 0
 ENDIF
=file

REM Ensures buffered data is written to file
DEF PROCFile_Flush
 IF @.size <> 0 AND @.writeflag THEN
  SYS "OS_GBPB",1,@.filehandle,@.block.data,@.size,@.ptr
  @.size = 0
 ENDIF
ENDPROC

REM Sets the file ptr of a file
DEF PROCFile_SetPtr(ptr)
 PROC@.Flush
 PTR#@.filehandle = ptr
ENDPROC

REM Reads some bytes into the file, used internally
DEF PROCFile_ReadBytes(numbytes,offset)
 LOCAL bytes
 PROC@.Flush
 SYS "OS_GBPB",3,@.filehandle,@.block.data+offset,numbytes,@.ptr TO ,,,bytes
 @.size = offset+numbytes-bytes
 @.ptr = @.ptr + numbytes-bytes
ENDPROC

REM Writes a line to a file, with \n terminator
DEF PROCFile_WriteLine(string$)
 LOCAL address
 IF @.writeflag THEN
  IF LEN(string$)+1 > (1024-@.size) THEN
   PROC@.Flush
  ENDIF
  address    =  @.block.data + @.size
  $address   =  string$+CHR$10
  @.size = @.size+ LEN(string$) + 1
 ENDIF
ENDPROC

REM Reads a line from a file, ignoring comments and preceding
REM whitespace. Comments start with a '#' as the first
REM non-whitespce char of a line
REM Returns "" on EOF
DEF FNFile_ReadLine
 LOCAL line$
 IF @.writeflag=0 THEN
  LOCAL ptr
  ptr = FNscan(@.block.data,10,@.size)
  IF ptr = -1 THEN
   IF @.size = 1024 THEN
    @.size=0
    =""
   ELSE
    PROC@.ReadBytes(1024-@.size,@.size)
    ptr = FNscan(@.block.data,10,@.size)
    IF ptr = -1 THEN
     @.size=0
     =""
    ENDIF
   ENDIF
  ENDIF
  ?(@.block.data+ptr) = 0
  line$=$@.block.data
  @.size-=LEN line$+1
  PROCmemcopy(@.block.data,@.block.data+LEN line$+1,@.size)
  line$=FNStrip(line$)
  IF LEFT$(line$,1)="#" THEN
   line$=FN@.ReadLine
  ENDIF
 ELSE
  @.size=0
  =""
 ENDIF
=line$
:
DEF FNFile_Eof
=(@.size=0) AND (EOF#@.filehandle)
:
DEF PROCFile_Destruct
IF @.filehandle<>0 THEN
 PROC@.Flush
 CLOSE #@.filehandle
ENDIF
REM Pass on to any other destructors
PROC@
ENDPROC
:
REM String stuff

REM Create a new string
DEF FNnewString(s$)
 LOCAL string
 string = NEW Class_String
 string.data$ = s$
=string
:
REM Comparison for integers (a string class)
DEF FNString_Compare(key)
IF @.data$=key.data$ THEN=TRUE
=FALSE
:
REM The string version
DEF FNString_CompareS(key$)
IF @.data$=key$ THEN=TRUE
=FALSE
:
REM Return a description
DEFFNString_String
=@.data$

REM Linked list stuff

DEF FNnewList
= NEW Class_List
:

REM Reads the first entry in the list, or 0 if none
DEF FNList_First
=@.items

REM Adds an item to the head of the list
DEF PROCList_Add(data)
 LOCAL item
 item = FNnew(FN@.GetDataType)
 item.data = data
 item.next = @.items
 @.items = item
ENDPROC
:
REM Add an item to the tail of a list
DEF PROCList_AddAtEnd(data)
LOCAL item,ptr,last
item = NEW FN@.GetDataType
item.data = data
ptr = @.items
WHILE ptr
 last=ptr:ptr = ptr.next
ENDWHILE
item.next = 0
IF last=0 THEN
 @.items = item
ELSE
 last.next = item
ENDIF
ENDPROC
:
REM Returns the type of the list element
DEF FNList_GetDataType
=Class_ListItem

REM Returns a list of filenames in directory dir$
REM matching match$
DEF FNnewListOfFilenames(dir$,match$)
 LOCAL list,buffer,cont,numread,file$,ptr,file
 list=FNnewList
 buffer=FNnewBlock(256)
 WHILE cont<>-1
  SYS "OS_GBPB",9,dir$,buffer.data,1024,cont,256,match$ TO ,,,numread,cont
  ptr=buffer.data
  LOCAL t
  WHILE numread>0
   file$=$ptr
   t=FNnewString(file$)
   PROClist.Add(t)
   ptr+=LEN file$+1
   numread-=1
  ENDWHILE
 ENDWHILE
=list

REM Call procedures with proc$(data) as parameter
DEF PROCList_Iterate(proc$)
 LOCAL next,list
 list=@.items
 WHILE list<>0
   REM next is used in case function$ changes the state of the
   REM linked list
   next = list.next
   PROC(proc$)(list.data)
   list = next
 ENDWHILE
ENDPROC
:
REM Deletes an item from the list
DEF PROCList_Delete(entry)
LOCAL last,this,next
this=@.items
last=0
WHILE this<>0
 next=this.next
 IF this.data=entry THEN
  IF last<>0 THEN
   last.next=next
   this.data=0
  ELSE
   IF next=0 THEN
    @.items = 0
   ELSE
    @.items = next
   ENDIF
  ENDIF
 ENDIF
 last=this
 this=next
ENDWHILE
ENDPROC
:
DEFFNList_Last
LOCAL this,next
this=@.items
WHILE this<>0
 next=this.next
 IF next=0 THEN=this
 this=next
ENDWHILE
REM No last item
=0
:
REM Find a channel matching a key
DEF FNList_Find(key)
 LOCAL list,found
 IF @.items = 0 THEN =0
 list = @.items
 WHILE list AND NOT found
  IF FNlist.data.Compare(key) THEN found=list
  list = list.next
 ENDWHILE
=found
:
REM Find a channel matching a string key
DEF FNList_FindS(key$)
 LOCAL list,found
 IF @.items = 0 THEN =0
 list = @.items
 WHILE list AND NOT found
  IF FNlist.data.CompareS(key$) THEN found=list
  list = list.next
 ENDWHILE
=found
:
REM Count the number of items in a list
DEF FNList_Count
 LOCAL list,count
 list = FN@.First
 WHILE list
  list = list.next
  count+=1
 ENDWHILE
=count
:
DEF PROCList_Construct
REM No items to begin with
@.items=0
REM Pass on to any other constructors
PROC@
ENDPROC
:
DEF PROCList_Destroy
IF @.items THEN
 PROC@.items.Destroy
 @.items=0
ENDIF
PROC@
ENDPROC
:
DEFFNList_String
LOCAL next,item,a$,t$
item=FN@.First
WHILE item
 next=item.next:t$=FNitem.data.String
 IF next=0 THEN
  a$+=t$
 ELSE
  IF next.next=0 THEN
   a$+=t$+" and "
  ELSE
   a$+=t$+", "
  ENDIF
 ENDIF
 item=next
ENDWHILE
=a$
:
REM Is this the right thing to do ?
DEFPROCListItem_Destroy
PROC@.data.Destroy
IF @.next THEN PROC@.next.Destroy
ENDPROC
:
REM recurse = 0 to not recurse, <level> for the number of levels
REM           to recurse, or -1 to recurse infinitely (dangerous)
DEF FNnewFileList(dir$,match$,recurse)
LOCAL list,buffer,cont,numread,file$,flist,subdptr
subdptr=FNnewString(dir$)
buffer=FNnewBlock(320)
list=FNnewList
WHILE cont<>-1
 SYS "OS_GBPB",12,dir$,buffer.data,1,cont,320,match$ TO ,,,numread,cont
 IF numread>0 THEN
  flist=NEW Class_FileList
  flist.parent=subdptr
  flist.filename$=$(buffer.data+24)
  flist.filetype=!(buffer.data+20)
  flist.attribs=!(buffer.data+20)
  flist.objtype=!(buffer.data+16)
  flist.length=!(buffer.data+8)
  IF recurse<>0 AND flist.objtype>1 THEN
   flist.subdir=FNnewFileList(dir$+"."+flist.filename$,match$,recurse-1)
  ELSE
   flist.subdir=0
  ENDIF
  PROClist.Add(flist)
 ENDIF
ENDWHILE
=list
:
REM **************************************************************
REM **  The Object methods, callable from *any* object at all   **
REM **************************************************************
:
DEF FNObject_GetUnknownVar(var$)
REM Deal with the dynamic properties of all objects, and some
REM which are calculated rather than stored in every object
CASE var$ OF
REM Object.type$ is the same as calling FNGetClassName(foo)
 WHEN "classname$"
  =FNGetClassName(@)
 WHEN "this"
  =@
 WHEN "classofme"
  =EVAL("Class_"+FNGetClassName(@))
ENDCASE
ERROR "Unknown property "+FNGetClassName(@)+"."+var$
=0
:
DEF PROCObject_SetUnknownVarStr(var$,value$)
CASE var$ OF
 WHEN "trevor$"
  PRINT FNGetClassName(@)+".trevor$ was set to "+value$
 OTHERWISE
  ERROR "Unknown property "+FNGetClassName(@)+"."+var$
ENDCASE
ENDPROC
:
DEF PROCObject_SetUnknownVarInt(var$,value)
CASE var$ OF
 OTHERWISE
  ERROR "Unknown property "+FNGetClassName(@)+"."+var$
ENDCASE
ENDPROC
